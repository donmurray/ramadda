<html>
<head>
<title>Developing  point data readers for RAMADDA</title>
</head>
<body>

We are going to look at how to develop a point data reader in RAMADDA.

First, check out the NLAS package from SourceForge:
<pre>
svn co https://nlas.svn.sourceforge.net/svnroot/nlas/trunk
</pre>

We'll use readers developed for IceBridge data. Change directory into:
<pre>
cd src/org/unavco/data/lidar/icebridge/
</pre>

and look at definerecords.tcl. This is the data dictionary that generates Java code for the various readers. To run this do:
<pre>
tclsh definerecords.tcl
</pre>


<h2>Mcords IRMCR2 Text Format</h2>
The Mcords IRMCR2  data looks like:
<pre>
LAT,LON,TIME,THICK,ELEVATION,FRAME,SURFACE,BOTTOM,QUALITY
76.807589,-48.918178,48974.2143,-9999.00,4158.4286,2007091001001, -5.87,-9999.00,0
76.807579,-48.917978,48974.2504,-9999.00,4158.5008,2007091001001, -4.63,-9999.00,0
76.807569,-48.917778,48974.2865,-9999.00,4158.5731,2007091001001, -3.40,-9999.00,0
</pre>


This data is read by a generated McordsIrmcr2File class. This class contains a
generated McordsIrmcr2Record class that does the actual reading. This code is generated by the
generateRecordClass  procedure
defined in ../..record/generate.tcl. The following arguments are used
<table cellpadding=5>
<tr valign=top><td><i>org.unavco.data.lidar.icebridge.McordsIrmcr2Record</i></td>
<td>Generate this Java class </td></tr>
<tr valign=top><td><i>-lineoriented 1</i></td>
<td>This is a text line oriented file, not a binary file</td></tr>
<tr valign=top><td><i>-delimiter {,}</i></td>
<td>Comma delimited</td></tr>
<tr valign=top><td><i>-skiplines 1</i></td>
<td> skip the first line in the text file. It is a header</td></tr>
<tr valign=top><td><i>-makefile 1</i></td><td>    
Normally, generateRecordClass generates just a Record class. This says to actually make a McordIrmcr2File class that
contains the Record class. This makes the reader self contained
</td></tr>
<tr valign=top><td><i>-filesuper org.ramadda.data.point.text.TextFile</i></td><td> This is the super class of the file class
</td></tr>
<tr valign=top><td><i>-super org.unavco.data.lidar.LidarRecord</i></td><td> This is the super class of the record
</td></tr>
<tr valign=top><td><ui>-fields</i></td><td>                                            
</td></tr>
<tr valign=top><td><i>{latitude double -declare 0}</i></td><td> 
Define a field called latitude of type double.
The -declare says to not declare the latitude attribute in the Record class.
This uses the latitude attribute of the base PointRecord class. Look at
AtmIceSSNRecord in definerecords.tcl to see how to overwrite the getLatitude 
methods
</td></tr>

<tr valign=top><td><i>{longitude double  -declare 0}</i></td><td> 
</td></tr>

<tr valign=top><td><i>{time double}</i></td><td> 
</td></tr>

<tr valign=top><td><i>{thickness double -missing "-9999.0" -chartable true  } </i>
</td><td> Specify a missing value and set the chartable flag. The chartable is used by RAMADDA to determine what fields
are chartable.
</td></tr>

<tr valign=top><td><i>{altitude double -chartable true  -declare 0}</i>
</td><td>  This uses the altitude attribute of the base class.
</td></tr>

<tr valign=top><td><i>{frame int}</i>
</td><td> 
</td></tr>

<tr valign=top><td><i>{surface double -chartable true -missing "-9999.0"}</i>
</td><td> 
</td></tr>

<tr valign=top><td><i>{bottom double -chartable true -missing "-9999.0"}</i>
</td><td> 
</td></tr>

<tr valign=top><td><i>{quality int -chartable true }</i>
</td></tr>
</table>


The generated  McordIrmcr2File class has  a main that can be used to test, e.g.:<pre>
java org.unavco.data.lidar.icebridge.McordIrmcr2File &lt;data file&gt;
</pre>




<h2>ATM QFit Data</h2>
The ATM QFit data is a binary format. There are 3 different record structures - 10 word, 12 word and 14 word.
We use the code generation facility to generate readers for each of these formats. 
<pre>
generateRecordClass org.unavco.data.lidar.icebridge.QFit10WordRecord  
    -super org.unavco.data.lidar.icebridge.QfitRecord  -fields  { 
    { relativeTime int -declare 0}
    { laserLatitude int -declare 0}
    { laserLongitude int -declare 0}
    { elevation int -declare 0  -unit mm}
    { startSignalStrength int }
    { reflectedSignalStrength int }
    { azimuth int -unit millidegree}
    { pitch int -unit millidegree}
    { roll int -unit millidegree}
    { gpsTime int }
}
</pre>

The records all have some common fields - relativeTime, latitude, longitude and elevation. These fields have various scaling factors. 
We declare those fields in the base (hand written) QfitRecord class and that class in turn implements the
getLatitude, getLongitude, etc., methods, scaling the integer values accordingly.

The QfitFile is not generated. It handles the logic of determining what record format the file is in, its endianness and pulls out 
the base date from the file name. 


<h2>AMRC Text Files</h2>
This example is in the core RAMADDA source tree. Check it out from Sourceforge:
<pre>
svn co https://ramadda.svn.sourceforge.net/svnroot/ramadda
cd src/org/ramadda/data/point/amrc
</pre>


</body>
</html>
